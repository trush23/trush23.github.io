<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-09-08">

<title>Ensembles: Part II. – Leanrning Math, Physics, and AI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-99258d85ffddbd9841977770f8edb96b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
<link rel="canonical" href="https://trushphysicsai.substack.com/p/ensembles-part-ii">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Leanrning Math, Physics, and AI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Ed. Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../outreach.html"> 
<span class="menu-text">Outreach</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../talks.html"> 
<span class="menu-text">Talks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:tsm4@nyu.edu" target="_blank"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Ensembles: Part II.</h1>
  <div class="quarto-categories">
    <div class="quarto-category">physics</div>
    <div class="quarto-category">ai</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 8, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>(Note: This post is a bit long)</p>
<p>In my previous post (Ensembles Part I), I described at the basic level, the way ensembles are used in physics. In this post, I will explore how the same concept is implemented in ML, DL, and AI. There has been a lot of work done on the statistical mechanics of Deep Learning and AI, but those are naturally very mathematical and quite advanced [1,2,3]. Here, I am restricting myself to examples of ensemble approach in different models and methods.</p>
<p>Before I begin, a historical sidebar is in order:</p>
<p><mark>As a student, I got introduced to ensembles via Statistical Mechanics in physics and naturally assumed that one of the luminaries of statistical mechanics must have invented it. Recently though, while reading some very old papers (a longtime hobby of mine and for background research for another publication I plan to start), I came across a public lecture by James Clerk Maxwell [4], who credits statisticians processing census data with inventing this method of ensembles in early to mid 1800s. I look at this not as a game of who did it first but a natural consequence of intersection of ideas. The whole of AI is built upon the foundations of Statistics, Mathematics, Computer Science, and Physics. The relevant extract of the lecture is at the end of this post.</mark></p>
<p>Back to the main theme…</p>
<p>There are two fundamental aspects to consider when we apply ML methods to any problem.</p>
<p>The first is to recognize and remember that in ML and AI, we are always trying to find and analyze <strong>patterned states</strong>.</p>
<p>This is the biggest point of divergence between systems in Physics and ML. In physics we are typically dealing with systems at equilibrium or states of maximum entropy, whereas in any ML, DL, AI, the goal is to identify, classify, predict patterns. A patterned state by definition is one of lower entropy compared to randomly distributed data.</p>
<p>It is not that physics models can’t deal with patterns, of course they do, from all sorts of waves to crystal structures and turbulent flow etc. etc. but when we are dealing with systems not at equilibrium, at the very least, we have to be careful how we extend the methods of equilibrium situations. Classic examples of this are <strong>non-equilibrium thermodynamics and pattern formation in dynamical systems</strong>.</p>
<p>The second aspect is to differentiate between the machinery/algorithm/model used to catch those patterns and the pattern itself. A snapshot of a cat is a patterned state compared to random pixel values, but a model to classify it as a cat has its own training dynamics and ideally it reaches its own equilibrium state when it has “recognized” that pattern. Given that we stop the training at some specified point using some cutoffs, it is probably more accurate to say that the model reaches its own “steady state”.</p>
<p>A dynamical or non-equilibrium thermodynamic steady state is different than true equilibrium. It is a state that while being patterned, maintains that pattern for a long time (indefinitely in principle unless disturbed). Think of zebra stripes or the vortex of a tornado, or even our body temperature or the body itself. Incidentally, the grandfather of AI, Alan Turing, was the first one to model and analyze patterns generated out of chemical reactions using <strong>Reaction-Diffusion equations</strong> [5].</p>
<p>Now we can look at some specific situations of ensembles in ML and AI.</p>
<p>There are four main types of data that get used in pretty much all of AI— text, images, tabular data, and audio. Video can be considered essentially as a combination of the above. Irrespective of the data modality, in majority of the cases, we are not looking for any kind of exact function that describes something (unlike in math or physics). We are usually performing statistical inferencing or “solving” the issue at hand in a statistical manner. We are answering questions like how many times the model correctly describes the data or what is the most likely event or outcome given what we know has happened. Whether it is about predicting the next word or identifying cats vs dogs, or forecasting stock prices, we “train” our models to some satisfactory accuracy and use them to answer questions in a statistical manner with some confidence level.</p>
<p>One way or another, pretty much every model or method, requires either creation of or partitioning of data in ways that amount to creating ensembles. Apart from a few models like Random Forests, this subtle issue is not explicitly mentioned but it is present nonetheless. I will elaborate this point by using the following examples:</p>
<ul>
<li><p>Random Forests</p></li>
<li><p>Data Augmentation</p></li>
<li><p>Surrogate and Synthetic Data</p></li>
<li><p>Generative AI</p></li>
</ul>
<p>I will not go into text data or time series data because both require their own separate treatment; because of the way we use language in a context dependent manner for text data and the importance of chronological order in time series data. I will just point out that creation of ensembles is an essential first step because it is about data preparation and data processing and the success of a model critically depends on it.</p>
<p><strong>Random Forests (RF)</strong>:</p>
<p>Suppose you are trying to analyze an issue that may (or may not) depend on a bunch of variables. You are not sure how many variables or which ones are the most relevant. So you collect data for all of the possible variables or do what you can. For the sake of concreteness, lets say we have some data about people and we have both categorical and numerical variables like age, gender, highest degree, annual income, height, weight, marital status, employment, favorite color, favorite cuisine, etc. etc. The question we need answered is not terribly important here, but in principle, we could make a single decision tree by factoring in every single variable and running through that decision tree. At worst, we may have to assign some arbitrary cutoffs for numerical variables to decide whether to go down one path or the other. It is possible but somewhat fixed and rigid process.</p>
<p>This is where Random Forests come in [6]. Instead of dealing with all the variables at once, we make a decision tree with a few variables, a subset of total number of variables. We do this at each node where we are deciding which path to follow. <strong>The collection of all such decisions trees is called, for obvious reasons, a Random Forest. But in essence, we have created an ensemble of decision trees</strong>.</p>
<p>We do this because a single decision tree is susceptible to “over fitting”, meaning it works mostly for that dataset and that question. It is also susceptible to giving wildly different answers when we make tiny changes to the data—– it has high variance. When we create an ensemble of decision trees, we are in effect saying that we don’t know which variables are the most relevant and which ones are not, let that emerge from the process. Since we also run through many randomized combinations of variables at each node, the variance decreases. Occasionally, we may get a wildly different result but generally (and hopefully) they will follow some sensible distribution with a well-defined peak or most probable outcome.</p>
<p>This may not look like the “gas in a box” scenario at first glance, but we are going through “micro-states” of trees and an outlier result is like all of the gas in a corner! What is different is that instead of one fixed macro variable, we have a distribution of final answers. What we do with that depends on whether the problem was regression or classification. For regression problem, we want our “micro-states” to inform us about a certain relationship between dependent and independent variables and we get to that desired outcome by imposing minimum standard error (MSE) requirement. For classification problems, instead of one fixed macro variable value, we have two classes (for simplicity), and every outcome is put in one class or the other and misclassification error is minimized.</p>
<p>A sidebar:</p>
<p><mark>A cute demo of something similar to RFs is what’s known as Galton’s Board. A particle is dropped through wooden pegs. Depending on which path it takes, it lands somewhere, but when we repeat the experiment for a large number of particles, or create ensembles and average them out, we get a Gaussian distribution. The most probable outcome is peaked right below the root node. Check out: <a href="https://imgur.com/gallery/galton-board-uALvLTe" class="uri">https://imgur.com/gallery/galton-board-uALvLTe</a> and <a href="https://en.wikipedia.org/wiki/Galton_board" class="uri">https://en.wikipedia.org/wiki/Galton_board</a>.</mark></p>
<p>There are too many subtle nuances in going from DTs to RFs in terms of implementation, efficiency of algorithm, splitting the data into training and testing, cost function to minimize, etc. Each of these in turn relies on the fact that we are working with ensembles and a priori it is not obvious how should we go about creating them. All such attempts at improving the basic method give rise to new approaches like bagging, gradient boosting, and the most popular of them all, XGBoost. I will go over the details of statistical methods within RFs in a dedicated post about it later in this series.</p>
<p><strong>Data Augmentation:</strong></p>
<p>Almost every DL and AI model dealing with images employs “data augmentation”. While it doesn’t say so explicitly, when we do that, we are creating or expanding an ensemble. Let’s see why it can be seen as such with images as a typical example.</p>
<p>Let’s say we are dealing with recognizing cats vs.&nbsp;dogs. We have a bunch of pictures of each category. Irrespective of what model we use, the first thing we do is to standardize and normalize those images in terms of size, intensity values, etc. Now, the logic goes that while we have these specific pictures, it could have been a slightly shifted picture, or maybe the camera was at an angle and the picture got rotated, or it was an extreme closeup etc. but it is still the same cat! Computationally, we apply various transformations like horizontal and vertical shifts, scaling, rotations, shearing, flipping, etc.</p>
<p>Recall from earlier that any ensemble is a collection of “snapshots” of the system and by doing data augmentation we are filling potentially missing but valid variations (micro-states) of the system. The caveat here is that this correspondence with statistical mechanical idea of ensembles of micro-states is not exact. In almost every problem, there are always some variations that are downright impossible or impractical and misleading at the very least. This is why we don’t apply any random transformation we feel like but stick with a select set of transformations that seem to make the ensemble and the method better. For example, if we are working on identifying cars on the road from images, flipping the images and showing upsidedown cars is unrealistic and probably not very useful. Another quick example is the figure below. You will never see different patches of an image randomly scrambled up as an “augmented” image, even though the distribution of pixel intensities is exactly the same.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="cats.jpg" class="img-fluid figure-img"></p>
<figcaption>Cat vs.&nbsp;Augmented Cat</figcaption>
</figure>
</div>
<p>There is a mathematical basis for this in terms of types of transformations that preserve certain features and the types that don’t. Notice that in some sense, <strong>we still need to keep some things constant as we create our ensembles</strong>, like the temperature or pressure in physical systems. Here, exactly what needs to stay constant (more or less) is not clear. Sometimes it is the probability distribution of some feature or features, the entire data, certain symmetries in the data, some mathematical structure or some as yet unknown thing that makes the whole thing work. We don’t know in general. More on all that in another dedicated post later.</p>
<p><strong>Resampling, Surrogate Data, and Synthetic Data</strong>:</p>
<p>In tabular data, we can’t generally do data augmentation arbitrarily. We can’t randomly add fake employees to create bigger HR dataset! What we can do on occasion is to create multiple copies of the data with changes in the order of the data (if the order is not critical) or equivalent changes to some features. Again, it is not that straightforward to know whether we are somehow introducing more bias in the system or not. The idea is to maintain the distribution of the features and the dataset as a whole. adding similar data is called the surrogate method. It is used not just in tabular data but in time series data as well. There is a long history of analyzing chaotic dynamical systems using surrogate data. A collection of such copies of original data will again be an ensemble. The more representative the ensemble is the better.</p>
<p>Synthetic data is based purely on the idea that the certain features follow some specific distribution of values. The idea is to create datasets by pulling numbers from these distributions randomly and create an ensemble of datasets.</p>
<p>Finally, the most basic step in any method is the “train-test” split or a separate validation set also included sometimes. There is usual practice is to do something like 80/20 split, where 80% of the data is used for training and 20% for testing. Since the training data is picked at random (while keeping various caveats in mind), we can get an ensemble of train-test pair. Each time a model is run on a slightly different training dataset (Resampling), we will get a different performance on the test dataset. This is for a different reason than the model converging on some small value of error or a high value of accuracy at later epochs.</p>
<p>We still don’t have a first-principles theory of the whole connection between data ensembles and ML/AI methods. Even within one specific model, we don’t have the full theory like in statistical physics, but we do know that elements from equilibrium and non-equilibrium statistical physics do seem to be applicable to strangely different problems like identifying cats vs.&nbsp;dogs.</p>
<p>We need to only look at generative AI to know this. Creating a new image from a supplied image or text is built upon principles of non-equilibrium thermodynamics and diffusion (hence the name “stable diffusion”). The idea is to add noise to the starting system, let it evolve and guide it to a different steady state via diffusion. Obviously, this is an oversimplified explanation and there is rigorous math and statistical physics involved in it but here I just want to mention that generative AI as we have it would not work without it.</p>
<p>Over the course of this series of posts, I will revisit each of these concepts individually with key mathematics and physics concepts that are involved and that seem to make these models work even though we don’t know exactly how or why. We do know that if we apply these concepts as if our problems were similar to a thermodynamic system and if we tune everything just right (hyper-parameter tuning), then we can do all sorts of things like detecting diseases to forecasting sales figures; anything that requires finding patterns buried within the data.</p>
<p>In my next post, I will explore the concept of <strong>entropy</strong>. A much used concept found in both physics and information science and used extensively in ML/AI in multiple ways.</p>
<p>In the meanwhile, a few questions to ponder over:</p>
<ol class="example" type="1">
<li><p>Think of image augmentation. At what point, as we keep transforming say a cat picture, it is no longer recognizable as a cat? Is it an abrupt process or gradual? What is changing mathematically (shape, size, colors, orientation?) and context-wise as we keep transforming an image? Is there anything that still stays constant? What should an ensemble for ML/AI problems be like (preferred properties)?</p></li>
<li><p>Can we have more dramatic transformations like the picture below where we block out certain areas? This is what is known as occlusion studies, where only a part of the object is visible. Here, we are obviously changing the distribution of pixel intensities as well, yet we can easily identify a cat. The question is how to make an algorithm identify it.</p></li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="covered_cat.jpg" class="img-fluid figure-img"></p>
<figcaption>Cat vs.&nbsp;Augmented Cat</figcaption>
</figure>
</div>
<ol start="3" class="example" type="1">
<li>We haven’t talked about text data but common sense tells us that just to create multiple variations of a sentence, and hence an ensemble, we cannot randomly shuffle around letters because then the meaning is destroyed. Can we create an ensemble by adding a bunch of useless words to a sentence and call it “another version”? How about using synonyms for every word whenever possible?</li>
</ol>
<p>The main point behind these questions is to emphasize that we actually don’t know for sure. We have hints and clues and sometimes mathematical or contextual reasons for all of the questions above but no theory from some kind of first principles, which is why pretty much everything, even very simple questions, are still or should be topics of research.</p>
<p>As promised at the beginning, pictures of James Clerk Maxwell’s Lecture on Diffusion, where he talks about Section F (statistics division) coming up with the ensemble approach. Hope you enjoyed this rather long post.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="maxwell.jpg" class="img-fluid figure-img"></p>
<figcaption>Cat vs.&nbsp;Augmented Cat</figcaption>
</figure>
</div>
<p><strong>References</strong>:</p>
<ol start="4" class="example" type="1">
<li><p>“Statistical Mechanics of Deep Learning”, Bahri et al., Annual Review of Condensed Matter<br>
Physics (2020).11:501–28.</p></li>
<li><p>“Statistical mechanics of deep learning”, Freya Behrens et al., J. Stat. Mech. (2024) 104007.</p></li>
<li><p>“SETOL: A Semi-Empirical Theory of (Deep) Learning”, Charles Martin and Christopher Hinrichs, arXiv:2507.17912v2 [cs.LG], (2025).</p></li>
<li><p>“MOLECULES”, James Clerk-Maxwell, The College Courant, Nov.&nbsp;8, 1873, Vol. 13, No.&nbsp;17, pp. 193-197.</p></li>
<li><p>“Random Decision Forests”, Tin Kam Ho, Proceedings of 3rd International Conference on Document Analysis and Recognition, Montreal, QC, Canada, 1995, pp.&nbsp;278-282 vol.1.</p></li>
<li><p>“The chemical basis of morphogenesis”, Phil. Trans. R. Soc. Lond. B 237:37-72.</p></li>
</ol>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>